# 什么是CPU调度，CPU调度完全攻略

CPU调度是多道程序操作系统的基础。通过在进程间切换 CPU，操作系统可以使得计算机更加高效。

对于单处理器系统，同一时间只有一个进程可以运行；其他进程都应等待，直到 CPU 空闲并可调度为止。多道程序的目标是，始终允许某个进程运行以最大化 CPU 利用率。

这种想法比较简单。一个进程执行直到它应等待为止，通常等待某个 I/O 请求的完成。对于简单的计算机系统，CPU 就处于闲置状态。所有这些等待时间就会浪费，没有完成任何有用工作。采用多道程序，我们试图有效利用这个时间。多个进程同时处于内存。当一个进程等待时，操作系统就从该进程接管 CPU 控制，并将 CPU 交给另一进程。这种方式不断重复。当一个进程必须等待时，另一进程接管 CPU 使用权。

这种调度是操作系统的基本功能。几乎所有计算机资源在使用前都要调度。当然，CPU 是最重要的计算机资源之一。因此，CPU 调度是操作系统设计的重要部分。

## 调度准则

​    不同的CPU调度算法具有不同的属性，且可能对某些进程更为有利。为了比较CPU调度算法，分析员提出了许多准则，这些准则包括如下：

**CPU使用率**：需要使CPU尽可能忙。从概念上讲，CPU使用率0%-100%。对于真实系统，它应从40%(轻负荷系统)~90%（重负荷系统）

**吞吐量**：如果CPU忙于执行进程，那么就有工作在完成。一种测量工作量的方法称为吞吐量，它指一个时间单元内所完成进程的数量。对于长进程，吞吐量可能为每小时一个进程；对于短进程，吞吐量可能为每秒10个进程。

**周转时间**：从一个特定进程的角度来看，一个重要准则是运行该进程需要多长时间。从进程提交到进程完成的时间称为周转时间。周转时间为所有时间段之和，包括等待进入内存，在就绪队列中等待，在CPU上执行和I/O执行。

**等待时间**：CPU调度算法并不影响进程运行和执行I/O的时间；它只影响进程在就绪队列中等待所花的时间。等待时间为在就绪队列中等待所花费时间之和。

**响应时间**：对于交互系统，周转时间并不是最佳准则。通常，进程能相当早就产生输出，并继续计算新结果同时输出以前的结果给用户。因此，另一时间是从提交请求道产生第一响应的时间。这种时间称为响应时间，是从开始响应所需的时间，而不是输出响应所需要的时间。周转时间通常受输出设备速度的限制。

**需要使CPU使用率和吞吐量最大化，而使周转时间、等待时间和响应时间最小化。在绝大多数情况下，需要优化平均值。不过在有的情况下，需要优化最小值或最大值，而不是平均值。例如，为了保证所有用户都得到好的服务，可能需要使最大响应时间最小。**

## CPU-I/O执行周期

CPU 的调度成功取决于如下观察到的进程属性，进程执行包括周期进行 CPU 执行和 I/O 等待。进程在这两个状态之间不断交替。

进程执行从 CPU 执行开始，之后 I/O 执行；接着另一个 CPU 执行，接着另一个 I/O 执行；等等。最终，最后的 CPU 执行通过系统请求结束，以便终止执行

## 抢占调度

一个进程在运行期间，不断地从一种状态转换到另一种状态，它可以多次处于就绪状态和执行状态，也可以多次处于阻塞状态。
　(1) 就绪－>执行
就绪状态是指进程获得了调度程序为之分配的除了CPU时间之外的其他必要资源，只要CPU时间一到位就可执行了。
处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成执行状态。
　(2) 执行－>就绪
处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态。
　(3) 执行－>阻塞
正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。
　(4) 阻塞－>就绪
处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。

需要进行 CPU 调度的情况可分为以下四种：

1. 当一个进程从运行状态切换到等待状态时（例如，I/O 请求，或 wait() 调用以便等待一个子进程的终止)。
2. 当一个进程从运行状态切换到就绪状态时（例如，当出现中断时）。
3. 当一个进程从等待状态切换到就绪状态时（例如，I/O 完成）。
4. 当一个进程终止时。


对于第 1 种和第 4 种情况，除了调度没有选择。一个新进程（如果就绪队列有一个进程存在）必须被选择执行。不过，对于第 2 种和第 3 种情况，还是有选择的。

如果调度只能发生在第 1 种和第 4 种情况下，则调度方案称为非抢占的或协作的；否则，调度方案称为抢占的。在非抢占调度下，一旦某个进程分配到 CPU，该进程就会一直使用 CPU，直到它终止或切换到等待状态。

Windows 3.x 就使用这种调度方法。Windows 95 引入抢占调度，所有之后的 Windows 操作系统都使用了抢占调度。Macintosh 操作系统 Mac OS X 采用抢占调度，而之前的 Macintosh 操作系统采用协作调度。协作调度在有些硬件平台上是唯一的方法，因为它不需要特殊硬件（如定时器）来支持抢占调度。

不过，当多个进程共享数据时，抢占调度可能导致竞争情况。假设两个进程共享数据。当第一个进程正在更新数据时，它被抢占以便第二个进程能够运行。然后，第二个进程可能试图读数据，但是这时该数据处于不一致的状态（可以使用互斥锁、信号量等方法解决）。

抢占也影响操作系统的内核设计。在处理系统调用时，内核可能为进程而忙于某个活动。这些活动可能涉及改变重要的内核数据（如 I/O 队列）。如果一个进程在进行这些修改时被抢占，并且内核（或设备驱动）需要读取或修改同样的结构，那么会有什么结果呢？

肯定导致混乱。有的操作系统（包括大多数 UNIX 系统）这样处理问题：在上下文切换前，等待系统调用的完成，或者等待 I/O 阻塞的发生。这种方案确保内核结构的简单，这是因为在内核[数据结构](http://c.biancheng.net/data_structure/)处于不一致状态时，内核不会抢占进程。遗憾的是，这种内核执行模式对于实时计算的支持较差（实时系统的任务应在给定时间内执行完成）。

因为根据定义中断可能随时发生，而且不能总是被内核所忽视，所以受中断影响的代码段应加以保护，从而避免同时使用。操作系统需要几乎任何时候都能接受中断，否则输入会被丢失或者输出会被改写。为了这些代码段不被多个进程同时访问，在进入时禁用中断而在退出时启用中断。重要的是，要注意禁用中断的代码段并不经常发生，而且常常只有少量指令。

## CPU调度程序

与 CPU 调度功能有关的另一个组件是调度程序。调度程序是一个模块，用来将 CPU 控制交给由短期调度程序选择的进程。

调度程序的功能包括：

- 切换上下文。
- 切换到用户模式。
- 跳转到用户程序的合适位置，以便重新启动程序。


调度程序应尽可能快，因为在每次进程切换时都要使用。调度程序停止一个进程而启动另一个所需的时间称为调度延迟。

每当 CPU 空闲时，操作系统就应从就绪队列中选择一个进程来执行。进程选择采用短期调度程序或 CPU 调度程序。调度程序从内存中选择一个能够执行的进程，并为其分配 CPU。

注意，就绪队列不必是先进先出（FIFO）队列。其实现可以是 FIFO 队列、优先队列、树或简单的无序链表等。然而，在概念上，就绪队列内的所有进程都要排队以便等待在 CPU 上运行。队列内的记录通常为**进程控制块**(PCB)。

## CPU调度算法

**多级队列调度**
多级队列调度算法（multilevel queue scheduling algorithm）将就绪队列分成多个独立队列。根据进程的属性，如内存大小、进程优先级、进程类型，一个进程被永久地分配到一个队列中。每个队列都有自己的调度算法。例如，前台进程和后台进程可处于不同队列。前台队列可能采用RR算法调度，而后台队列可能采用FCFS算法调度。

另外，队列之间必须有调度，通常采用固定优先级抢占调度。每个队列与更低层队列相对有绝对优先级。例如，只有系统进程、交互进程和交互编辑进程队列都为空，批处理队列内的进程才可运行。如果在一个批处理进程运行时有一个交互进程进入就绪队列，那么该批处理进程会被抢占。

另一种可能是在队列之间划分时间片。每个队列都有一定的CPU时间，这可用于调度队列内的进程。例如，对于前台-后台队列的例子，前台队列可以有80%的CPU时间用于在进程之间进行RR调度，而后台队列可以有20%的CPU时间采用FCFS算法调度进程。

**多级反馈队列调度**
通常在使用多级队列调度算法时，进程进入系统时被永久地分配到一个队列。例如，如果前台进程和后台进程分别有独立队列，进程并不从队列转移到另一个队列，这是因为进程并不改变前台或后台性质。这种设置的优点是低调度开销，缺点是不够灵活。

与之相反多级反馈队列调度算法（multilevel feedback queue scheduling algorithm）允许进程在队列之间移动。主要思想是根据不同CPU区间的特点以区分进程。如果进程使用过多的CPU时间，那么它会被转移到更低优先级队列。这种方案将I/O约束和交互进程留在更高优先级队列。此外，在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列。这种形式的老化阻止了饥饿的发生。

通常，多级反馈队列调度程序可由下列参数来定义：

1. 队列数量
2. 每个队列的调度算法
3. 用以确定何时降级到更低优先级队列的方法
4. 用以确定进程在需要服务时应进入哪个队列的方法
5. 多级反馈队列调度程序的定义使它成为最普通的CPU调度算法。

它可被配置以适应特定系统设计。不幸的是，由于需要一些方法来选择参数以定义最佳的调度程序，它也是最复杂的算法。